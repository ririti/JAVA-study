객체지향 7장

상속

정의: 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것

장점 : 1. 보다 적은 양의 코드로 새로운 클래스를 작성가능

\2. 코드를 공통적으로 관리 가능해서 코드의 추가 변경이 매우 용이하다

조상 클래스 : parent class, super class, base class

자손 클래스 : child class, sub class, derived class

\- 생성자와 초기화 블록은 상속되지 않는다. 멤버만 상속됨

\- 자손 클래스의 멤버 개수는 조상 클래스보다 항상 같거나 많다.

(조상 클래스에서 멤버를 상속 받기 때문에 자손 클래스는 조상클래스보다 많을 수없다)

자손 클래스의 인스턴스를 생성하면 조상 클래스의 멤버도 함께 생성되기 때문에 따로 조상 클래스의 인스턴스를 생성하지 않아도 조상 클래스의 멤버들을 사용 가능

클래스 간의 관계 – 포함관계

한 클래스의 멤버변수로 다른 클래스 타입의 참조변수를 선언하는 것을 뜻함

상속관계 : ~은 ~이다 (is-a)

포함관계 : ~은 ~을 가지고 있다.(has-a)

단일 상속

자바의 객체지향의 경우는 단 하나만을 상속 허용

C++과는 다름

다중상속을 허용하면 복합적인 기능을 가진 클래스로 쉽게 작성하지만 자바는  그것을 포기하고 단일 속성만 허용하여 클래스 간의 관계가 보다 명확해지고 코드를 더욱 신뢰 할 수 있게 만들어 준다.


Object클래스 – 모든 클래스의 조상

모든 클래스 상속계층도의 최상위에 있는 클래스

그 동안 toString()이나 equals(Object o)와 같은 메서드를 따로 정의하지 않고도 사용 할 수 있었던 것은 Object클래스에 정의된 것들이기 때문이다.

오버라이딩

조상 클래스로부터 상속받은 메서드의 내용을 변경하는 것을 오버라이딩이라 한다.

오버라이딩의 조건

자손 클래스에서 오버라이딩하는 메서드는 조상 클래스의 메서드와

- 이름이 같아야 한다.
- 매개변수가 같아야 한다.
- 반환타입이 같아야 한다.
1. 접근 제어자는 조상 클래스의 메서드보다 좁은 범위로 변경 할 수 없다.
- Public, protected, (default), private 순으로 좁다. 여기서 만약 조상의 제어자가 protected라면 자손클래스에서 바꿀 수 있는 제어자는 public과 protected두개다 좁은 범위로는 바꿀 수 없다.
1. 조상 클래스의 메서드보다 많은 수의 예외를 선언할 수 없다.

조상 클래스의 메서드를 자손 클래스에서 오버라이딩할 때

1) 접근 제어자를 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다.
1) 예외는 조상 클래스의 메서드보다 많이 선언할 수 없다.
1) 인스턴스 메서드를 static메서드로 또는 그 반대로 변경할 수 없다.

오버로딩 vs 오버라이딩

오버로딩 : 기존에 없는 새로운 메서드를 추가하는 것(new)

오버라이딩 : 상속받은 메서드의 내용을 변경하는 것 (change, modify)

Super

상속받은 멤버와 자신의 멤버와 이름이 같을 때는 super을 붙여서 구별

조상의 멤버와 자신의 멤버를  구별하는데 사용된다는 점을 제외하고는 super과 this는  근본적으로 같다. 

static메서드는 인스턴스와 관련이 없기 때문에 super을 사용할 수 없고 인스턴스 메서드에서만 사용 가능하다.

Super() – 조상 클래스의 생성자

` `조상 클래스 멤버의 초기화 작업이 수행되어야 하기 때문에 자손 클래스의 생성자에서 조상 클래스의 생성자가 호출되어야함

생성자의 첫 줄에 조상클래스의 생성자를 호출해야 하는 이유는 자손 클래스의 멤버가 조상 클래스의 멤버를 사용할 수도 있으므로 조상의 멤버들이 먼저 초기화 되어야한다.

Object클래스를 제외한 모든 클래스의 생성자 첫 줄에 생성자, this(), super()를 호출해야한다. 그렇지 않으면 컴파일러가 자동적으로 ‘super();’를 생성자의 첫 줄에 삽입한다. 

Package와 import

패키지

클래스의 묶음;

장점

서로 관련된 클래스들끼리 그룹 단위로 묶어 놓아서 효율적으로 관리 가능

클래스가 물리적으로 하나의 클래스파일인 것과 같이 패키지는 물리적으로 하나의 디렉토리이다.

- 하나의 소스파일에는 첫 번째 문장으로 단 한 번의 패키지 선언만을 허용
- 모든 클래스는 반드시 하나의 패키지에 속해야 한다.
- 패키지는 점(.)을 구분자로 하여 계층구조로 구성 가능
- 패키지는 물리적으로 클래스 파일을 포함하는 하나의 디렉토리이다.

패지키의 선언

클래스나 인터페이스의 소스파일 의 맨 위에 package 패키지명으로 선언 가능

Import문의 선언

인반적인 소스파일의 구성 순서

1. Package문
1. Import문
1. 클래스 선언

선언 방법

Import 패키지명.클래스명; or import  패키지명;

Static import문

Static import문을 사용하면 static멤버를 호출할 때 클래스 이름을 생략가능 하다.

Ex) System.out.println(Math.random()); -> out.println(random());

제어자

제어자란? 

클래스, 변수 또는 메서드의 선언부에 함께 사용되어 부가적인 의미를 부여한다.

접근 제어자 – public protected default private

그 외 – static final abstract native transient synchronized volatile strictfp

클래스나 멤버변수와 메서드에 주로 사용됨 

하나의 대상에 대해서 여러 제어자를 조합하여 사용가능

단, 접근 제어자는 한 번에 네가지 중 하나만 사용 가능

Static – 클래스의, 공통적인

인스턴스변수는 하나의 클래스로부터 생성되었더라도 각기 다른 값을 가질 수 있지만 클래스변수(static멤버변수)는 인스턴스에 관계없이  같은 값을 갖는다. 하나의 변수를 모든 인스턴스가 공유하기 때문.

Static이 사용될 수 있는 곳 – 멤버변수, 메서드, 초기화 블록

멤버 변수 

- ` `모든 인스턴스에 공통적으로 사용되는 클래스 변수가됨
- 클래스가 메모링 로드될 때 생성
- 클래스 변수는 인스턴스를 생성하지 않고도 사용 가능

메서드

- 인스턴스를 생성하지 않고도 호출이 가능한 static 메서드가 된다
- static메서드 내에서는 인스턴스멤버들을 직접 사용 불가

final – 마지막의 변경될 수 없는

대부분 모든 대상에 사용 가능

\- 변수에 사용되면 변하지 않는 상수가됨 

\- 메소드에 사용될 경우 오버라이딩 불가능

\- 클래스에 사용될 경우 자신을 확장하는 자손클래스를 정의하지 못함

생성자를 이용한 final멤버 변수의 초기화

인스턴스변수의 경우 생성자에서 초기화 되도록 가능

클래스 내에 매개변수를 갖는 생성자를 선언하여 인스턴스를 생성할 때 final이 붙은 멤버변수를 초기화하는데 필요한 값을 생성자의 매개변수로부터 제공 받는 것이다.

각 인스턴스마다  final이 붙은 인스턴스변수는 모든 인스턴스에서 같은 값을 가져야만 할 것이다.

Abstract - 추상의 미완성의

` `메서드의 선언부만 작성하고 실제 수행내용은 구현하지 않은 추상 메서드를 선언하는데 사용됨

클래스 – 클래스 내에 추상 메서드가 선언되어 있음을 의미

메서드 – 선언부만 작성하고 구현부는 작성하지 않은 추상 메서드임을 알린다.

미완성 설계도 이므로 인스턴스를 생성할 수 없다.

장점 : 클래스 자체로는 쓸모가 없지만 상속받아서 일부의 원하는 메서드만 오버라이딩 해도 된다는 장점이 있다.

접근 제어자

멤버 또는 클래스에 사용되며 해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 제안하는 역할


