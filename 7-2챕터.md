Private : 같은 클래스 내에서만 접근 가능

Default : 같은 패키지 내에서만 접근 가능

Protected : 같은 패키지 내에서, 그리고 다른 패키지의 자손클래스에서만 접근 가능

Public 접근 제한이 없다

Public > protected > default > private 순으로 넓다

접근 제어자를 이용한 캡슐화

클래스의 내부에 선언된 데이터를 보호하기 위해

데이터의 유효한 값을 유지하도록 , 비밀번호와 같은 데이터를 외부에서 함부로 변경하지 못하도록 제한함

이를 데이터 감추기 또는 객체지향개념의 캡슐화라함

접근 제어자를 사용하는 이유

- 외부로부터 데이터를 보호하기 위해서
- 외부에서는 불필요한 내부적으로만 사용되는 부분을 감추기 위해서

Get멤버변수 : 보통 멤버변수의 값을 읽는 메서드

set멥버변수  : 멤버변수의 값을 변경하는 메서드

생성자의 접근 제어

생성자에 접근 제어자를 사용하여 인스턴스의 생성을 제한 가능

외부에서 생성자에 접근할 수 없으므로 인스턴스를 생성 할 수 없 지만  클래스 내부에서는 인스턴스를 생성할 수 있다.

private클래스는 다른 클래스의 조상이 될 수 없다.

-이유는 자손클래스의 인스턴스를 생성할 때 조상클래스의 생성자를 호출해야만 하는데 생성자의 접근 제어자가 private이므로 자손클래스에서 호출이 불가능

제어자의 조합

1. 메서드에 static과 abstract를 함께 사용할 수 없다.
- static메서드는 몸통이 있는 메서드에만 사용가능
1. 클래스에 abstract와 final을 동시에 사용 불가
- 클래스에 사용되는 final은 클래스를 확장할 수 없다는 의미
- Abstract는 상속을 통해서 완성되어야 한다는 의미여서 서로 모순된다
1. abstract메서드의 접근 제어자가 private일 수 없다
- abstract메서드는 자손클래스에서 구현해주어야 하는데 접근 제어자가 private이면 자손클래스에서 접근이 불가능
1. 메서드의 private과 final을 같이 사용할 필요는 없다
- 접근 제어자가 private인 메서드는 오버라이딩될 수 없기 때문. 둘 중 하나만써도 의미는 충분하다

다형성

다형성이란?

객체직향개념에서 다형성이란 여러 가지 형태를 가질 수 있는 능력을 의미

조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조할 수 있도록 하였다

Ex) Tv  t =new CaptionTv() p.355

CaptionTv c = new Caption();

Tv           t =  new Caption();

t보다 c가 더 많이 쓸 수 있음

둘다 같은 타입의 인스턴스지만 참조변수의 타입에 따라 사용가능한 멤버의 개수가 달라짐 

참조변수가 사용할 수 있는 멤버의 개수는 인스턴스의 멤버 개수보다 같거나 적어야 한다.

- 조상타입의 참조변수로 자손타입의 인스턴스를 참조 가능
- 반대로 자손타입의 참조변수로 조상타입의 인스턴스를 참조 불가능

참조변수의 형변환

기본형 변수와 같이 참조변수도 형변환 가능

하지만 서로 상속관계에 있는 클래스에서만 가능하기 때문에 자손타입의 참조변수를 조상타입의 참조변수로, 조상타입의 참조변수를 자손타입의 참조변수로의 형변환만 가능

자손타입 -> 조상타입(UP casting) : 형변환 생략가능

자손타입 <- 조상타입(Down casting) : 형변환 생략 불가능

다운캐스팅 : 조상타입의 참조변수를 자손 타입으로 변환하는 것

업 캐스팅 : 자손 타입의 참조변수를 조상 타입으로 변환 하는 것

형변환은 참조하고 있는 인스턴스에서 사용 할 수 있는 멤버의 (범위)개수를 조절

instanceof연산자

참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위함

주로 조건문에 사용

(참조변수) instanceof (클래스명)

연산결과 true를 얻으면 검사한 타입으로 변환이 가능하다

참조변수와 인스턴스의 연결

중복으로 정의된 경우

조상타입의 참조변수를 사용했을 때는 조상클래스에 선언된 멤버변수가 사용

자손타입의 참조변수를 사용했을 때는 자손타입의 선언된 멤버변수가 사용

중복되지 않았을 경우

조상타입의 참조변수를 사용했을 때와 자손타입의 참조변수를 사용했을 때의 차이는 없다.

매개변수의 다형성

메서드의 매개변수에도 적용가능

여러 종류의 객체를 배열로 다루기 p370




5.추상클래스

미완성 설계도에 비유할 수 있다.

추상클래스는 인스턴스를 생성 불가능

상속을 통해서 자손클래스에 의해서만 완성 가능하다.

추상클래스는 추상메서드를 포함하고있다는 것을 제외하고 일반클래스와 차이가 없다.

추상클래스는 생성자가 있고 멤버변수와 메서드를 가질 수 있다.

\1. 추상메서드를 포함하지 않는 클래스에도ㅓ abstract를 붙여서 추상클래스로 선언 가능하다

\2. 추상메서드가 없는 클래스라 할지라도 추상클래스로 지정되면 인스턴스를 생성 할 수 없다.

메서드 = 선언부 + 구현부로 구성

추상메서드 = 선언부만 작성하고 구현부는 작성하지 않는다

메서드를 미완성으로 남겨 놓는 이유

메서드의 내용이 상속받는 클래스에 따라 달라질 수 있기 때문에 조상 클래스에서는 선언부만을 작성하고 주석을 붙여서 어떤 기능을 수행할 목적으로 작성되었는지 알려주고 실제 내용은 상속받는 클래스에서 구현하도록 비워 두는 것이다.

그래서 추상클래스를 상속받는 자손 클래스는 초상의 추상 메서드를 상황에 맞게 적절히 구현해주어야 한다.

추상화 : 클래스간의 공통점을 찾아내서 공통의 조상을 만드는 작업

구체화 : 상속을 통해 클래스를 구현 확장하는 작업

인터페이스

인터페이스 멤버들의 제약

- 모든 멤버변수는 public static final 이어야 하며, 이를 생략 가능
- 모든 메서드는 public abstract 이어야 하며, 이를 생략가능 하다

단, static메서드와 디폴트 메서드는 예외 생략불가능;

인터페이스의 상속

인터페이스는 인터페이스로부터만 상속 가능

클래스와는 달리 다중상속, 여러 개의 인터페이스로부터 상속 가능하다

인터페이스의 구현

추상클래스 처럼 인스턴스 생성불가능

인터페이스도 자신에 정의된 추상메서드의 몸통을 만들어주는 클래스를 작성해야한다.

Extends가 아니라 구현한다는 의미의 implements를 사용한다.





인터페이스의 장점

- 개발시간을 단축시킬 수있다.
- 표준화가 가능하다.
- 서로 관계없는 클래스들에게 관계를 맺어 줄 수 있다.
- 독립적인 프로그래밍이 가능하다.

1. 개발시간을 단축시킬 수 있다.

메서드를 호출하는 쪽에서는 메서드의 내용과 관계없이 선언부만 알면 되기 때문

동시에 다른 한 쪽에서는 인터페이스를 구현하는 클래스를 작성하게 하면, 인터페이스를 구현하는 클래스가 작성될 때까지 기다리지 않고도 양쪽에서 동시에 개발 진행 가능

2.표준화가 가능하다.

3.서로 관계없는 클래스들에게 관계를 맺어 줄 수 있다.

4.독립적인 프로그래밍이 가능하다.

-클래스의 선언과 구현을 분리시킬 수 있기 때문에 실제구현에 독립적인 프로그램을 작성하는 것이 가능.

7.8 인터페이스의 이해

\- 클래스를 사용하는 쪽(User)과 클래스를 제공하는 쪽(Provider)이 있다.

\- 메서드를 사용하는 쪽에서는 사용하려는 메서드의 선언부만 알면 된다.(내용은 몰라도됨)


